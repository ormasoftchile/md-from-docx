<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline';">
  <title>Paste from Word</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--vscode-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
      background-color: var(--vscode-editor-background, #1e1e1e);
      color: var(--vscode-editor-foreground, #d4d4d4);
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    h1 {
      font-size: 1.5em;
      margin-bottom: 10px;
      color: var(--vscode-foreground, #cccccc);
    }

    .instructions {
      margin-bottom: 20px;
      color: var(--vscode-descriptionForeground, #8b8b8b);
      font-size: 0.9em;
    }

    .paste-area {
      flex: 1;
      min-height: 300px;
      border: 2px dashed var(--vscode-input-border, #3c3c3c);
      border-radius: 8px;
      padding: 20px;
      background-color: var(--vscode-input-background, #3c3c3c);
      color: var(--vscode-input-foreground, #cccccc);
      overflow: auto;
      cursor: text;
      transition: border-color 0.2s, background-color 0.2s;
    }

    .paste-area:focus {
      outline: none;
      border-color: var(--vscode-focusBorder, #007acc);
      background-color: var(--vscode-inputOption-activeBackground, #2a2d2e);
    }

    .paste-area.has-content {
      border-style: solid;
    }

    .paste-area::before {
      content: 'Click here and paste your content (Ctrl+V / Cmd+V)';
      color: var(--vscode-input-placeholderForeground, #6b6b6b);
      pointer-events: none;
    }

    .paste-area.has-content::before {
      content: '';
    }

    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 4px;
      font-size: 0.9em;
      display: none;
    }

    .status.success {
      display: block;
      background-color: var(--vscode-testing-iconPassed, #388a34);
      color: white;
    }

    .status.error {
      display: block;
      background-color: var(--vscode-testing-iconFailed, #c72e2e);
      color: white;
    }

    .status.info {
      display: block;
      background-color: var(--vscode-inputValidation-infoBackground, #063b49);
      border: 1px solid var(--vscode-inputValidation-infoBorder, #007acc);
    }

    .button-container {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }

    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      font-size: 0.9em;
      cursor: pointer;
      background-color: var(--vscode-button-background, #0e639c);
      color: var(--vscode-button-foreground, white);
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: var(--vscode-button-hoverBackground, #1177bb);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    button.secondary {
      background-color: var(--vscode-button-secondaryBackground, #3a3d41);
      color: var(--vscode-button-secondaryForeground, white);
    }

    button.secondary:hover {
      background-color: var(--vscode-button-secondaryHoverBackground, #45494e);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸ“‹ Paste from Word</h1>
    <p class="instructions">
      Copy content from Microsoft Word (or any rich text source), then paste it below. 
      The content will be converted to Markdown with images extracted.
    </p>
    
    <div 
      class="paste-area" 
      id="pasteArea" 
      contenteditable="true" 
      tabindex="0"
    ></div>
    
    <div id="status" class="status"></div>
    
    <div class="button-container">
      <button id="convertBtn" disabled>Convert to Markdown</button>
      <button id="clearBtn" class="secondary">Clear</button>
    </div>
  </div>

  <script>
    // VS Code API
    const vscode = acquireVsCodeApi();
    
    // DOM elements
    const pasteArea = document.getElementById('pasteArea');
    const statusDiv = document.getElementById('status');
    const convertBtn = document.getElementById('convertBtn');
    const clearBtn = document.getElementById('clearBtn');

    // Captured data
    let capturedHtml = '';
    let capturedImages = [];

    // Focus paste area on load
    setTimeout(() => pasteArea.focus(), 100);

    // Handle paste event
    pasteArea.addEventListener('paste', (event) => {
      event.preventDefault();
      
      const clipboardData = event.clipboardData;
      if (!clipboardData) {
        showStatus('error', 'Could not access clipboard data');
        return;
      }

      // Try to get HTML content
      const html = clipboardData.getData('text/html');
      const plainText = clipboardData.getData('text/plain');

      // Extract images from clipboard items
      const images = [];
      const items = clipboardData.items;
      
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.type.startsWith('image/')) {
          const blob = item.getAsFile();
          if (blob) {
            const reader = new FileReader();
            reader.onload = (e) => {
              images.push({
                dataUri: e.target.result,
                index: images.length
              });
              updateConvertButton();
            };
            reader.readAsDataURL(blob);
          }
        }
      }

      if (html) {
        // Rich content - process HTML
        capturedHtml = html;
        capturedImages = images;
        
        // Show preview in paste area
        pasteArea.innerHTML = html;
        pasteArea.classList.add('has-content');
        
        showStatus('success', `âœ“ Rich content captured. ${images.length > 0 ? `Found ${images.length} image(s).` : ''} Click "Convert to Markdown" to proceed.`);
        convertBtn.disabled = false;
        
      } else if (plainText) {
        // Plain text only
        capturedHtml = '';
        capturedImages = [];
        
        pasteArea.innerText = plainText;
        pasteArea.classList.add('has-content');
        
        showStatus('info', 'Plain text pasted. This will be converted as-is (no formatting).');
        
        // Send plain text directly
        vscode.postMessage({
          type: 'paste',
          payload: {
            html: '',
            plainText: plainText,
            images: [],
            hasRichContent: false
          }
        });
        
      } else {
        showStatus('error', 'No content found in clipboard');
      }
    });

    // Convert button click
    convertBtn.addEventListener('click', () => {
      if (!capturedHtml && capturedImages.length === 0) {
        showStatus('error', 'No content to convert');
        return;
      }

      // Debug: Search for the metric card content
      console.log('=== SEARCHING FOR METRIC CARDS ===');
      console.log('Contains "Repos Onboarded":', capturedHtml.includes('Repos Onboarded'));
      console.log('Contains "SpecKit POCs":', capturedHtml.includes('SpecKit POCs'));
      console.log('Contains "Key Metrics":', capturedHtml.includes('Key Metrics'));
      
      // Find the context around "Repos Onboarded" if it exists
      const reposIdx = capturedHtml.indexOf('Repos Onboarded');
      if (reposIdx > -1) {
        console.log('=== CONTEXT AROUND "Repos Onboarded" (500 chars before/after) ===');
        console.log(capturedHtml.substring(Math.max(0, reposIdx - 500), reposIdx + 500));
      }

      // Debug: Log full HTML length and search for image-like patterns
      console.log('=== HTML LENGTH:', capturedHtml.length, '===');
      
      // Look for various image patterns
      const patterns = {
        'img tags': (capturedHtml.match(/<img/gi) || []).length,
        'svg tags': (capturedHtml.match(/<svg/gi) || []).length,
        'canvas tags': (capturedHtml.match(/<canvas/gi) || []).length,
        'background-image': (capturedHtml.match(/background-image/gi) || []).length,
        'blob: URLs': (capturedHtml.match(/blob:/gi) || []).length,
        'data:image': (capturedHtml.match(/data:image/gi) || []).length,
      };
      console.log('=== IMAGE PATTERNS FOUND ===', patterns);

      const embeddedImages = [];

      // Extract embedded images from HTML (data URIs in img src)
      const imgRegex = /<img[^>]+src=["'](data:image\/[^"']+)["'][^>]*>/gi;
      let match;
      while ((match = imgRegex.exec(capturedHtml)) !== null) {
        embeddedImages.push({
          dataUri: match[1],
          index: embeddedImages.length
        });
      }

      // Extract SVGs and convert to data URIs
      // Match complete SVG elements including nested content
      const svgRegex = /<svg[^>]*>[\s\S]*?<\/svg>/gi;
      const svgMatches = capturedHtml.match(svgRegex) || [];
      console.log('=== SVG ELEMENTS FOUND:', svgMatches.length, '===');
      
      svgMatches.forEach((svgContent, idx) => {
        // Skip tiny SVGs (likely icons, not content images)
        // Check for meaningful size - look for width/height attributes or viewBox
        const svgLength = svgContent.length;
        
        console.log(`SVG ${idx}: length=${svgLength}`);
        
        // Only convert LARGE SVGs (>3000 chars) that are likely real images/diagrams
        // Small SVGs (<3000 chars) are typically emojis/icons - skip them entirely
        if (svgLength > 3000) {
          // Ensure SVG has xmlns for standalone use
          let svgForConversion = svgContent;
          if (!svgForConversion.includes('xmlns=')) {
            svgForConversion = svgForConversion.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
          }
          
          // Convert SVG to data URI
          const encoded = btoa(unescape(encodeURIComponent(svgForConversion)));
          const dataUri = `data:image/svg+xml;base64,${encoded}`;
          
          embeddedImages.push({
            dataUri: dataUri,
            index: embeddedImages.length,
            type: 'svg'
          });
          
          console.log(`SVG ${idx} converted to data URI (real image)`);
        } else {
          console.log(`SVG ${idx} skipped (small icon/emoji)`);
        }
      });

      // Also extract VML images (Word charts/shapes)
      const vmlRegex = /<v:imagedata[^>]+src=["']([^"']+)["'][^>]*>/gi;
      while ((match = vmlRegex.exec(capturedHtml)) !== null) {
        const src = match[1];
        if (src.startsWith('data:image/')) {
          embeddedImages.push({
            dataUri: src,
            index: embeddedImages.length
          });
        }
      }

      // Extract images from background-image styles
      const bgRegex = /background-image:\s*url\(["']?(data:image\/[^"')]+)["']?\)/gi;
      while ((match = bgRegex.exec(capturedHtml)) !== null) {
        embeddedImages.push({
          dataUri: match[1],
          index: embeddedImages.length
        });
      }

      console.log('Total embedded images (including SVGs):', embeddedImages.length);

      // Combine with directly pasted images
      const allImages = [...capturedImages, ...embeddedImages];

      // Replace SVGs in HTML with img placeholders pointing to the extracted images
      // Remove small SVGs (icons) entirely
      let processedHtml = capturedHtml;
      let svgIndex = 0;
      processedHtml = processedHtml.replace(svgRegex, (svgContent) => {
        const svgLength = svgContent.length;
        
        if (svgLength > 3000) {
          // Large SVG - replace with img tag pointing to extracted image
          const imgData = embeddedImages.find(img => img.type === 'svg' && img.index === svgIndex);
          svgIndex++;
          if (imgData) {
            return `<img src="${imgData.dataUri}" alt="diagram" />`;
          }
        }
        // Small SVGs (icons/emojis) - remove entirely
        return '';
      });

      // Send to extension
      vscode.postMessage({
        type: 'paste',
        payload: {
          html: processedHtml,
          images: allImages.map(img => img.dataUri),
          hasRichContent: true
        }
      });

      showStatus('success', 'Converting... Please wait.');
      convertBtn.disabled = true;
    });

    // Clear button click
    clearBtn.addEventListener('click', () => {
      pasteArea.innerHTML = '';
      pasteArea.classList.remove('has-content');
      capturedHtml = '';
      capturedImages = [];
      convertBtn.disabled = true;
      hideStatus();
      pasteArea.focus();
    });

    // Helper functions
    function showStatus(type, message) {
      statusDiv.className = 'status ' + type;
      statusDiv.textContent = message;
    }

    function hideStatus() {
      statusDiv.className = 'status';
    }

    function updateConvertButton() {
      convertBtn.disabled = !capturedHtml && capturedImages.length === 0;
    }

    // Handle messages from extension
    window.addEventListener('message', (event) => {
      const message = event.data;
      
      switch (message.type) {
        case 'success':
          showStatus('success', message.message || 'Conversion complete!');
          break;
        case 'error':
          showStatus('error', message.message || 'Conversion failed');
          convertBtn.disabled = false;
          break;
        case 'close':
          // Extension will handle closing
          break;
      }
    });
  </script>
</body>
</html>
